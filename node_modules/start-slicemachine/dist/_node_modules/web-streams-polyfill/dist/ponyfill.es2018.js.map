{"version":3,"file":"ponyfill.es2018.js","sources":["../../../../../../node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"],"sourcesContent":["/**\n * web-streams-polyfill v3.2.1\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WebStreamsPolyfill = {}));\n}(this, (function (exports) { 'use strict';\n\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n        Symbol :\n        description => `Symbol(${description})`;\n\n    /// <reference lib=\"dom\" />\n    function noop() {\n        return undefined;\n    }\n    function getGlobals() {\n        if (typeof self !== 'undefined') {\n            return self;\n        }\n        else if (typeof window !== 'undefined') {\n            return window;\n        }\n        else if (typeof global !== 'undefined') {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n\n    function typeIsObject(x) {\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\n    }\n    const rethrowAssertionErrorRejection = noop;\n\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseResolve = Promise.resolve.bind(originalPromise);\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    function promiseResolvedWith(value) {\n        return originalPromiseResolve(value);\n    }\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    const queueMicrotask = (() => {\n        const globalQueueMicrotask = globals && globals.queueMicrotask;\n        if (typeof globalQueueMicrotask === 'function') {\n            return globalQueueMicrotask;\n        }\n        const resolvedPromise = promiseResolvedWith(undefined);\n        return (fn) => PerformPromiseThen(resolvedPromise, fn);\n    })();\n    function reflectCall(F, V, args) {\n        if (typeof F !== 'function') {\n            throw new TypeError('Argument is not a function');\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        }\n        catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */\n    class SimpleQueue {\n        constructor() {\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() { // must not be called on an empty queue\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while (i !== elements.length || node._next !== undefined) {\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() { // must not be called on an empty queue\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === 'readable') {\n            defaultReaderClosedPromiseInitialize(reader);\n        }\n        else if (stream._state === 'closed') {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        }\n        else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        if (reader._ownerReadableStream._state === 'readable') {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        reader._ownerReadableStream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError('Cannot ' + name + ' a stream using a released reader');\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject) => {\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n\n    const AbortSteps = SymbolPolyfill('[[AbortSteps]]');\n    const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n    const CancelSteps = SymbolPolyfill('[[CancelSteps]]');\n    const PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function (x) {\n        return typeof x === 'number' && isFinite(x);\n    };\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function (v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === 'object' || typeof x === 'function';\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== 'function') {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return (typeof x === 'object' && x !== null) || typeof x === 'function';\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        }\n        else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */\n    class ReadableStreamDefaultReader {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n            assertReadableStream(stream, 'First parameter');\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('cancel'));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */\n        read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('read from'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n                _errorSteps: e => rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */\n        releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException('releaseLock');\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readRequests.length > 0) {\n                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamDefaultReader',\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === 'closed') {\n            readRequest._closeSteps();\n        }\n        else if (stream._state === 'errored') {\n            readRequest._errorSteps(stream._storedError);\n        }\n        else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */\n    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);\n\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel) {\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = () => this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ?\n                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n                nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = () => this._returnSteps(value);\n            return this._ongoingPromise ?\n                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n                returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({ value: undefined, done: true });\n            }\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('iterate'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n                },\n                _closeSteps: () => {\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({ value: undefined, done: true });\n                },\n                _errorSteps: reason => {\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({ value, done: true });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (reader._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('finish iterating'));\n            }\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, () => ({ value, done: true }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({ value, done: true });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next() {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return(value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof\n                ReadableStreamAsyncIteratorImpl;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function (x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    // Not implemented correctly\n    function TransferArrayBuffer(O) {\n        return O;\n    }\n    // Not implemented correctly\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function IsDetachedBuffer(O) {\n        return false;\n    }\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== 'number') {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n        }\n        container._queue.push({ value, size });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */\n    class ReadableStreamBYOBRequest {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */\n        get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('view');\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('respond');\n            }\n            assertRequiredArgument(bytesWritten, 1, 'respond');\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError('This BYOB request has been invalidated');\n            }\n            if (IsDetachedBuffer(this._view.buffer)) ;\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException('respondWithNewView');\n            }\n            assertRequiredArgument(view, 1, 'respondWithNewView');\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError('You can only respond with array buffer views');\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError('This BYOB request has been invalidated');\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: { enumerable: true },\n        respondWithNewView: { enumerable: true },\n        view: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamBYOBRequest',\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class ReadableByteStreamController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */\n        get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('byobRequest');\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */\n        get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('desiredSize');\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */\n        close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('close');\n            }\n            if (this._closeRequested) {\n                throw new TypeError('The stream has already been closed; do not close it again!');\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== 'readable') {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('enqueue');\n            }\n            assertRequiredArgument(chunk, 1, 'enqueue');\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError('chunk must be an array buffer view');\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError('chunk must have non-zero byteLength');\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError('stream is closed or draining');\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== 'readable') {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */\n        error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException('error');\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */\n        [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                const entry = this._queue.shift();\n                this._queueTotalSize -= entry.byteLength;\n                ReadableByteStreamControllerHandleQueueDrain(this);\n                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n                readRequest._chunkSteps(view);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                }\n                catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: 'default'\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        byobRequest: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableByteStreamController',\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n        }, e => {\n            ReadableByteStreamControllerError(controller, e);\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === 'closed') {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === 'default') {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        }\n        else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({ buffer, byteOffset, byteLength });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const elementSize = pullIntoDescriptor.elementSize;\n        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        if (maxAlignedBytes > currentAlignedBytes) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while (totalBytesToCopyRemaining > 0) {\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            }\n            else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        }\n        else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while (controller._pendingPullIntos.length > 0) {\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        let elementSize = 1;\n        if (view.constructor !== DataView) {\n            elementSize = view.constructor.BYTES_PER_ELEMENT;\n        }\n        const ctor = view.constructor;\n        // try {\n        const buffer = TransferArrayBuffer(view.buffer);\n        // } catch (e) {\n        //   readIntoRequest._errorSteps(e);\n        //   return;\n        // }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset: view.byteOffset,\n            byteLength: view.byteLength,\n            bytesFilled: 0,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: 'byob'\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === 'closed') {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            ReadableByteStreamControllerRespondInClosedState(controller);\n        }\n        else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== 'readable') {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== 'readable') {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled > 0) {\n                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== 'readable') {\n            return;\n        }\n        const buffer = chunk.buffer;\n        const byteOffset = chunk.byteOffset;\n        const byteLength = chunk.byteLength;\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n        }\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        if (ReadableStreamHasDefaultReader(stream)) {\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            }\n            else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        }\n        else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        }\n        else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== 'readable') {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'errored') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            if (bytesWritten !== 0) {\n                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n            }\n        }\n        else {\n            if (bytesWritten === 0) {\n                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError('bytesWritten out of range');\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === 'closed') {\n            if (view.byteLength !== 0) {\n                throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n            }\n        }\n        else {\n            if (view.byteLength === 0) {\n                throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError('The region specified by view does not match byobRequest');\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError('The buffer of view has different capacity than byobRequest');\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError('The region specified by view is larger than byobRequest');\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }, r => {\n            ReadableByteStreamControllerError(controller, r);\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm = () => undefined;\n        let pullAlgorithm = () => promiseResolvedWith(undefined);\n        let cancelAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = () => underlyingByteSource.start(controller);\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = () => underlyingByteSource.pull(controller);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError('autoAllocateChunkSize must be greater than 0');\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        }\n        else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */\n    class ReadableStreamBYOBReader {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n            assertReadableStream(stream, 'First parameter');\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                    'source');\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('cancel'));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Attempts to reads bytes into view, and returns a promise resolved with the result.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */\n        read(view) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException('read'));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) ;\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException('read from'));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject) => {\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n                _errorSteps: e => rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */\n        releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException('releaseLock');\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            if (this._readIntoRequests.length > 0) {\n                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n            }\n            ReadableStreamReaderGenericRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: { enumerable: true },\n        read: { enumerable: true },\n        releaseLock: { enumerable: true },\n        closed: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamBYOBReader',\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === 'errored') {\n            readIntoRequest._errorSteps(stream._storedError);\n        }\n        else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n        }\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError('Invalid highWaterMark');\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return () => 1;\n        }\n        return size;\n    }\n\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return chunk => convertUnrestrictedDouble(fn(chunk));\n    }\n\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ?\n                undefined :\n                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ?\n                undefined :\n                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ?\n                undefined :\n                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ?\n                undefined :\n                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return () => promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n    }\n\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n\n    function isAbortSignal(value) {\n        if (typeof value !== 'object' || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === 'boolean';\n        }\n        catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === 'function';\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */\n    function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */\n    class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            }\n            else {\n                assertObject(rawUnderlyingSink, 'First parameter');\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError('Invalid type is specified');\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */\n        get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2('locked');\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */\n        abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2('abort'));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */\n        close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2('close'));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */\n        getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2('getWriter');\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        getWriter: { enumerable: true },\n        locked: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStream',\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = 'writable';\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === 'closed' || stream._state === 'errored') {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === 'closed' || state === 'errored') {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === 'erroring') {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject) => {\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === 'closed' || state === 'errored') {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject) => {\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === 'writable') {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject) => {\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === 'writable') {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = 'erroring';\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = 'errored';\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach(writeRequest => {\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, () => {\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        }, (reason) => {\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === 'erroring') {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = 'closed';\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            }\n            else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */\n    class WritableStreamDefaultWriter {\n        constructor(stream) {\n            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n            assertWritableStream(stream, 'First parameter');\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === 'writable') {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                }\n                else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            }\n            else if (state === 'erroring') {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            }\n            else if (state === 'closed') {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            }\n            else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writers lock is released before the stream finishes closing.\n         */\n        get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writers lock is released.\n         */\n        get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException('desiredSize');\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException('desiredSize');\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n         * rejected.\n         */\n        get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */\n        abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('abort'));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */\n        close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('close'));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */\n        releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException('releaseLock');\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException('write to'));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: { enumerable: true },\n        close: { enumerable: true },\n        releaseLock: { enumerable: true },\n        write: { enumerable: true },\n        closed: { enumerable: true },\n        desiredSize: { enumerable: true },\n        ready: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStreamDefaultWriter',\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === 'pending') {\n            defaultWriterClosedPromiseReject(writer, error);\n        }\n        else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === 'pending') {\n            defaultWriterReadyPromiseReject(writer, error);\n        }\n        else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === 'errored' || state === 'erroring') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        const state = stream._state;\n        if (state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n        }\n        if (state === 'erroring') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class WritableStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */\n        get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('abortReason');\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */\n        get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('signal');\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */\n        error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2('error');\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== 'writable') {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */\n        [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: { enumerable: true },\n        signal: { enumerable: true },\n        error: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'WritableStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, () => {\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, r => {\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm = () => undefined;\n        let writeAlgorithm = () => promiseResolvedWith(undefined);\n        let closeAlgorithm = () => promiseResolvedWith(undefined);\n        let abortAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = () => underlyingSink.start(controller);\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = () => underlyingSink.close();\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = reason => underlyingSink.abort(reason);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === 'erroring') {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        }\n        else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === 'writable') {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, () => {\n            WritableStreamFinishInFlightClose(stream);\n        }, reason => {\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, () => {\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n        }, reason => {\n            if (stream._state === 'writable') {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError('Cannot ' + name + ' a stream using a released writer');\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject) => {\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = 'pending';\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = 'rejected';\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = 'resolved';\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject) => {\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = 'pending';\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = 'rejected';\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = 'fulfilled';\n    }\n\n    /// <reference lib=\"dom\" />\n    const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    function createDOMExceptionPolyfill() {\n        // eslint-disable-next-line no-shadow\n        const ctor = function DOMException(message, name) {\n            this.message = message || '';\n            this.name = name || 'Error';\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n        return ctor;\n    }\n    // eslint-disable-next-line no-redeclare\n    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject) => {\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = () => {\n                    const error = new DOMException$1('Aborted', 'AbortError');\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(() => {\n                            if (dest._state === 'writable') {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(() => {\n                            if (source._state === 'readable') {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener('abort', abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop) => {\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        }\n                        else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, () => {\n                    return newPromise((resolveRead, rejectRead) => {\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: chunk => {\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: () => resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, storedError => {\n                if (!preventAbort) {\n                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n                }\n                else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n                if (!preventCancel) {\n                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n                }\n                else {\n                    shutdown(true, storedError);\n                }\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, () => {\n                if (!preventClose) {\n                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                }\n                else {\n                    shutdown();\n                }\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n                if (!preventCancel) {\n                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n                }\n                else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === 'errored') {\n                    action(stream._storedError);\n                }\n                else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === 'closed') {\n                    action();\n                }\n                else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                }\n                else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n                }\n                else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener('abort', abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                }\n                else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }\n\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */\n    class ReadableStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */\n        get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('desiredSize');\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */\n        close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('close');\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError('The stream is not in a state that permits close');\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('enqueue');\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError('The stream is not in a state that permits enqueue');\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */\n        error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1('error');\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */\n        [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */\n        [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                }\n                else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            }\n            else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: { enumerable: true },\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, () => {\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n        }, e => {\n            ReadableStreamDefaultControllerError(controller, e);\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        }\n        else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            }\n            catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            }\n            catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== 'readable') {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === 'errored') {\n            return null;\n        }\n        if (state === 'closed') {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === 'readable') {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), () => {\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }, r => {\n            ReadableStreamDefaultControllerError(controller, r);\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm = () => undefined;\n        let pullAlgorithm = () => promiseResolvedWith(undefined);\n        let cancelAlgorithm = () => promiseResolvedWith(undefined);\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = () => underlyingSource.start(controller);\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = () => underlyingSource.pull(controller);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = reason => underlyingSource.cancel(reason);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise(resolve => {\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: () => {\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r) => {\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n        });\n        return [branch1, branch2];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise(resolve => {\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, r => {\n                if (thisReader !== reader) {\n                    return;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            }\n                            catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        }\n                        else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: () => {\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: chunk => {\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    queueMicrotask(() => {\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            }\n                            catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        }\n                        else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        }\n                        else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: chunk => {\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: () => {\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            }\n            else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            }\n            else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([reason1, reason2]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [branch1, branch2];\n    }\n\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n                undefined :\n                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ?\n                undefined :\n                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ?\n                undefined :\n                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ?\n                undefined :\n                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason) => promiseCall(fn, original, [reason]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== 'bytes') {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== 'byob') {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return { preventCancel: Boolean(preventCancel) };\n    }\n\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return { readable, writable };\n    }\n\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */\n    class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            }\n            else {\n                assertObject(rawUnderlyingSource, 'First parameter');\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n            InitializeReadableStream(this);\n            if (underlyingSource.type === 'bytes') {\n                if (strategy.size !== undefined) {\n                    throw new RangeError('The strategy for a byte stream cannot have a size function');\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            }\n            else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */\n        get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('locked');\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */\n        cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('getReader');\n            }\n            const options = convertReaderOptions(rawOptions, 'First parameter');\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('pipeThrough');\n            }\n            assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n            const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n            const options = convertPipeOptions(rawOptions, 'Second parameter');\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, 'Second parameter');\n            }\n            catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */\n        tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('tee');\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1('values');\n            }\n            const options = convertIteratorOptions(rawOptions, 'First parameter');\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n    }\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: { enumerable: true },\n        getReader: { enumerable: true },\n        pipeThrough: { enumerable: true },\n        pipeTo: { enumerable: true },\n        tee: { enumerable: true },\n        values: { enumerable: true },\n        locked: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ReadableStream',\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = 'readable';\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === 'closed') {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === 'errored') {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            reader._readIntoRequests.forEach(readIntoRequest => {\n                readIntoRequest._closeSteps(undefined);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = 'closed';\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach(readRequest => {\n                readRequest._closeSteps();\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = 'errored';\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            reader._readRequests.forEach(readRequest => {\n                readRequest._errorSteps(e);\n            });\n            reader._readRequests = new SimpleQueue();\n        }\n        else {\n            reader._readIntoRequests.forEach(readIntoRequest => {\n                readIntoRequest._errorSteps(e);\n            });\n            reader._readIntoRequests = new SimpleQueue();\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk) => {\n        return chunk.byteLength;\n    };\n    try {\n        Object.defineProperty(byteLengthSizeFunction, 'name', {\n            value: 'size',\n            configurable: true\n        });\n    }\n    catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */\n    class ByteLengthQueuingStrategy {\n        constructor(options) {\n            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n            options = convertQueuingStrategyInit(options, 'First parameter');\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */\n        get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException('highWaterMark');\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */\n        get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException('size');\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: 'ByteLengthQueuingStrategy',\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = () => {\n        return 1;\n    };\n    try {\n        Object.defineProperty(countSizeFunction, 'name', {\n            value: 'size',\n            configurable: true\n        });\n    }\n    catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n    }\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */\n    class CountQueuingStrategy {\n        constructor(options) {\n            assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n            options = convertQueuingStrategyInit(options, 'First parameter');\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */\n        get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException('highWaterMark');\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */\n        get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException('size');\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: { enumerable: true },\n        size: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: 'CountQueuingStrategy',\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            flush: flush === undefined ?\n                undefined :\n                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ?\n                undefined :\n                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ?\n                undefined :\n                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => promiseCall(fn, original, [controller]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller) => reflectCall(fn, original, [controller]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n    }\n\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */\n    class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n            const transformer = convertTransformer(rawTransformer, 'First parameter');\n            if (transformer.readableType !== undefined) {\n                throw new RangeError('Invalid readableType specified');\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError('Invalid writableType specified');\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise(resolve => {\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            }\n            else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */\n        get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException('readable');\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */\n        get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException('writable');\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: { enumerable: true },\n        writable: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: 'TransformStream',\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n            return promiseResolvedWith(undefined);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise(resolve => {\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */\n    class TransformStreamDefaultController {\n        constructor() {\n            throw new TypeError('Illegal constructor');\n        }\n        /**\n         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n         */\n        get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('desiredSize');\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('enqueue');\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */\n        error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('error');\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */\n        terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException('terminate');\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: { enumerable: true },\n        error: { enumerable: true },\n        terminate: { enumerable: true },\n        desiredSize: { enumerable: true }\n    });\n    if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: 'TransformStreamDefaultController',\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm = (chunk) => {\n            try {\n                TransformStreamDefaultControllerEnqueue(controller, chunk);\n                return promiseResolvedWith(undefined);\n            }\n            catch (transformResultE) {\n                return promiseRejectedWith(transformResultE);\n            }\n        };\n        let flushAlgorithm = () => promiseResolvedWith(undefined);\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = chunk => transformer.transform(chunk, controller);\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = () => transformer.flush(controller);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError('Readable side is not in a state that permits enqueue');\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        }\n        catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, r => {\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError('TransformStream terminated');\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, () => {\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === 'erroring') {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n        // errored.\n        TransformStreamError(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        const controller = stream._transformStreamController;\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        // Return a promise that is fulfilled with undefined on success.\n        return transformPromiseWith(flushPromise, () => {\n            if (readable._state === 'errored') {\n                throw readable._storedError;\n            }\n            ReadableStreamDefaultControllerClose(readable._readableStreamController);\n        }, r => {\n            TransformStreamError(stream, r);\n            throw readable._storedError;\n        });\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n\n    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports.CountQueuingStrategy = CountQueuingStrategy;\n    exports.ReadableByteStreamController = ReadableByteStreamController;\n    exports.ReadableStream = ReadableStream;\n    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports.TransformStream = TransformStream;\n    exports.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports.WritableStream = WritableStream;\n    exports.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ponyfill.es2018.js.map\n"],"names":["this","exports","global","DOMException"],"mappings":"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","x_google_ignoreList":[0]}