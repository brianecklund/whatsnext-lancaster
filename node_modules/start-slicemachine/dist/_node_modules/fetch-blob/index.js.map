{"version":3,"file":"index.js","sources":["../../../../../node_modules/fetch-blob/index.js"],"sourcesContent":["/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n"],"names":["size"],"mappings":"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","x_google_ignoreList":[0]}